apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: rem-postgres
  namespace: rem-api
spec:
  instances: 3
  primaryUpdateStrategy: unsupervised

  # PostgreSQL 18 with pgvector extension
  imageName: ghcr.io/cloudnative-pg/postgresql:18.1

  bootstrap:
    initdb:
      database: remdb
      owner: remuser
      secret:
        name: rem-database-credentials
      # Run SQL migrations from ConfigMap on first startup
      # ConfigMap generated from rem/sql/migrations/*.sql via ./manifests/generate-sql-configmap.sh
      postInitApplicationSQLRefs:
        configMapRefs:
          - name: rem-postgres-init-sql
            key: 001_install.sql
          - name: rem-postgres-init-sql
            key: 002_install_models.sql

  # Storage configuration
  # Available storage classes (configured in CDK):
  #   - gp3: General purpose SSD (3,000 IOPS, 125 MB/s, $0.08/GB-month)
  #     * Good for dev/testing and cost-sensitive workloads
  #   - gp3-postgres: PostgreSQL-optimized SSD (5,000 IOPS, 250 MB/s, ~$0.09/GB-month)
  #     * Recommended for most production PostgreSQL workloads
  #     * Higher IOPS and throughput for WAL writes
  #   - io2-postgres: Mission-critical SSD (10,000 IOPS, ~$0.19/GB-month)
  #     * <1ms latency, 99.999% durability
  #     * Best for mission-critical production databases
  #     * 2x cost vs gp3-postgres
  #
  # Recommendation:
  #   - Dev/Testing: gp3 (current)
  #   - Production: gp3-postgres (most use cases)
  #   - Mission-Critical: io2-postgres (high-value data)
  storage:
    size: 50Gi
    storageClass: gp3  # Change to gp3-postgres for production, io2-postgres for mission-critical
    resizeInUseVolumes: true

  # Backup configuration to S3
  backup:
    barmanObjectStore:
      destinationPath: s3://${REM_BACKUP_BUCKET}/postgresql/rem-postgres
      s3Credentials:
        inheritFromIAMRole: true  # Use Pod Identity via service account
      wal:
        compression: gzip
        maxParallel: 4
      data:
        compression: gzip
        jobs: 4
        immediateCheckpoint: true
    retentionPolicy: "30d"

    # Volume snapshots for faster recovery
    volumeSnapshot:
      className: ebs-csi
      snapshotOwnerReference: cluster
      online: true
      onlineConfiguration:
        waitForArchive: true
        immediateCheckpoint: true

  # PostgreSQL configuration optimized for AI workloads
  postgresql:
    parameters:
      # Connection settings
      max_connections: "300"

      # Memory settings (for 8GB pods)
      shared_buffers: "2GB"
      effective_cache_size: "6GB"
      maintenance_work_mem: "512MB"
      work_mem: "16MB"

      # WAL settings
      wal_buffers: "32MB"
      checkpoint_completion_target: "0.9"
      max_wal_size: "4GB"
      min_wal_size: "1GB"

      # Query planner
      default_statistics_target: "500"  # Higher for better vector query plans
      random_page_cost: "1.1"  # SSD-optimized
      effective_io_concurrency: "200"

      # Parallel query settings
      max_parallel_workers_per_gather: "4"
      max_parallel_workers: "8"
      max_worker_processes: "8"

      # pgvector-specific settings
      max_parallel_maintenance_workers: "4"

      # Autovacuum tuning for vector workloads
      autovacuum_max_workers: "4"
      autovacuum_naptime: "10s"

      # Logging
      log_checkpoints: "on"
      log_lock_waits: "on"
      log_temp_files: "0"
      log_autovacuum_min_duration: "0"

      # WAL archiving for PITR
      archive_mode: "on"
      archive_timeout: "5min"

  # Resource allocation
  resources:
    requests:
      memory: "4Gi"
      cpu: "2000m"
    limits:
      memory: "8Gi"
      cpu: "4000m"

  # Monitoring
  monitoring:
    enablePodMonitor: true
    podMonitorMetricRelabelings:
      - sourceLabels: [cluster]
        targetLabel: cnpg_cluster
        action: replace

  # Affinity rules for high availability
  affinity:
    enablePodAntiAffinity: true
    topologyKey: kubernetes.io/hostname
    podAntiAffinityType: required

  # Node selector for stateful workloads
  nodeSelector:
    workload-type: stateful

  # Tolerate stateful node taints
  tolerations:
    - key: workload-type
      operator: Equal
      value: stateful
      effect: NoSchedule

  # Service account for IRSA
  serviceAccountTemplate:
    metadata:
      annotations:
        eks.amazonaws.com/role-arn: ${REM_POSTGRES_ROLE_ARN}
