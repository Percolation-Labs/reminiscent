name: rem-eks-infra-yaml
description: REM EKS infrastructure with Karpenter using Crosswalk (simplified)
runtime: yaml

# Configuration variables with defaults
config:
  cluster_name:
    type: string
    default: rem-cluster
  cluster_version:
    type: string
    default: "1.32"
  node_desired_size:
    type: integer
    default: 2
  node_min_size:
    type: integer
    default: 1
  node_max_size:
    type: integer
    default: 3
  node_instance_type:
    type: string
    default: "t3.medium"
  karpenter_version:
    type: string
    default: "1.1.0"

resources:
  # ===========================================================================
  # VPC USING CROSSWALK (awsx)
  # ===========================================================================

  vpc:
    type: awsx:ec2:Vpc
    properties:
      cidrBlock: "10.0.0.0/16"
      numberOfAvailabilityZones: 3
      natGateways:
        strategy: "OnePerAz"
      tags:
        Name: ${cluster_name}-vpc

  # ===========================================================================
  # EKS CLUSTER USING eks:Cluster COMPONENT
  # ===========================================================================

  cluster:
    type: eks:Cluster
    properties:
      name: ${cluster_name}
      version: ${cluster_version}
      vpcId: ${vpc.vpcId}
      publicSubnetIds: ${vpc.publicSubnetIds}
      privateSubnetIds: ${vpc.privateSubnetIds}
      instanceType: ${node_instance_type}
      desiredCapacity: ${node_desired_size}
      minSize: ${node_min_size}
      maxSize: ${node_max_size}
      nodeAssociatePublicIpAddress: false
      skipDefaultNodeGroup: true
      createOidcProvider: true
      enabledClusterLogTypes:
        - api
        - audit
        - authenticator
        - controllerManager
        - scheduler

  # ===========================================================================
  # KARPENTER CONTROLLER SETUP
  # ===========================================================================

  # Karpenter Controller IAM Role (IRSA)
  karpenter-controller-role:
    type: aws:iam:Role
    properties:
      assumeRolePolicy:
        fn::toJSON:
          Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Principal:
                Federated: ${cluster.core.oidcProvider.arn}
              Action: sts:AssumeRoleWithWebIdentity
              Condition:
                StringEquals:
                  fn::toJSON:
                    ${cluster.core.oidcProvider.url}:sub: system:serviceaccount:karpenter:karpenter
                    ${cluster.core.oidcProvider.url}:aud: sts.amazonaws.com

  # Karpenter Controller Policy
  karpenter-controller-policy:
    type: aws:iam:RolePolicy
    properties:
      role: ${karpenter-controller-role.name}
      policy:
        fn::toJSON:
          Version: "2012-10-17"
          Statement:
            # EC2 Instance Management
            - Effect: Allow
              Action:
                - ec2:CreateFleet
                - ec2:CreateLaunchTemplate
                - ec2:CreateTags
                - ec2:DescribeAvailabilityZones
                - ec2:DescribeImages
                - ec2:DescribeInstances
                - ec2:DescribeInstanceTypeOfferings
                - ec2:DescribeInstanceTypes
                - ec2:DescribeLaunchTemplates
                - ec2:DescribeSecurityGroups
                - ec2:DescribeSpotPriceHistory
                - ec2:DescribeSubnets
                - ec2:DeleteLaunchTemplate
                - ec2:RunInstances
                - ec2:TerminateInstances
              Resource: "*"
            # IAM PassRole for node instances
            - Effect: Allow
              Action:
                - iam:PassRole
              Resource: ${cluster.instanceRoles[0]}
            # SSM for pricing data
            - Effect: Allow
              Action:
                - ssm:GetParameter
              Resource: "arn:aws:ssm:*:*:parameter/aws/service/*"
            # SQS for interruption handling
            - Effect: Allow
              Action:
                - sqs:DeleteMessage
                - sqs:GetQueueAttributes
                - sqs:GetQueueUrl
                - sqs:ReceiveMessage
              Resource: ${karpenter-interruption-queue.arn}
            # EKS Cluster Access
            - Effect: Allow
              Action:
                - eks:DescribeCluster
              Resource: ${cluster.eksCluster.arn}

  # SQS Queue for Spot Interruption Handling
  karpenter-interruption-queue:
    type: aws:sqs:Queue
    properties:
      name: ${cluster_name}-karpenter-interruptions
      messageRetentionSeconds: 300
      sqsManagedSseEnabled: true

  # EventBridge Rule for Spot Interruptions
  spot-interruption-rule:
    type: aws:cloudwatch:EventRule
    properties:
      name: ${cluster_name}-spot-interruption
      eventPattern:
        fn::toJSON:
          source:
            - aws.ec2
          detail-type:
            - EC2 Spot Instance Interruption Warning

  spot-interruption-target:
    type: aws:cloudwatch:EventTarget
    properties:
      rule: ${spot-interruption-rule.name}
      arn: ${karpenter-interruption-queue.arn}

  # EventBridge Rule for Instance Rebalance
  rebalance-rule:
    type: aws:cloudwatch:EventRule
    properties:
      name: ${cluster_name}-rebalance
      eventPattern:
        fn::toJSON:
          source:
            - aws.ec2
          detail-type:
            - EC2 Instance Rebalance Recommendation

  rebalance-target:
    type: aws:cloudwatch:EventTarget
    properties:
      rule: ${rebalance-rule.name}
      arn: ${karpenter-interruption-queue.arn}

  # EventBridge Rule for Scheduled Changes
  scheduled-change-rule:
    type: aws:cloudwatch:EventRule
    properties:
      name: ${cluster_name}-scheduled-change
      eventPattern:
        fn::toJSON:
          source:
            - aws.health
          detail-type:
            - AWS Health Event

  scheduled-change-target:
    type: aws:cloudwatch:EventTarget
    properties:
      rule: ${scheduled-change-rule.name}
      arn: ${karpenter-interruption-queue.arn}

  # SQS Queue Policy for EventBridge
  interruption-queue-policy:
    type: aws:sqs:QueuePolicy
    properties:
      queueUrl: ${karpenter-interruption-queue.url}
      policy:
        fn::toJSON:
          Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Principal:
                Service:
                  - events.amazonaws.com
                  - sqs.amazonaws.com
              Action:
                - sqs:SendMessage
              Resource: ${karpenter-interruption-queue.arn}

# Stack outputs
outputs:
  cluster_name: ${cluster.eksCluster.name}
  cluster_endpoint: ${cluster.eksCluster.endpoint}
  cluster_arn: ${cluster.eksCluster.arn}
  cluster_certificate_authority: ${cluster.eksCluster.certificateAuthority.data}
  kubeconfig: ${cluster.kubeconfig}
  kubeconfigJson: ${cluster.kubeconfigJson}
  oidc_provider_arn: ${cluster.core.oidcProvider.arn}
  oidc_provider_url: ${cluster.core.oidcProvider.url}
  vpc_id: ${vpc.vpcId}
  private_subnet_ids: ${vpc.privateSubnetIds}
  public_subnet_ids: ${vpc.publicSubnetIds}
  karpenter_node_role_arn: ${cluster.instanceRoles[0]}
  karpenter_controller_role_arn: ${karpenter-controller-role.arn}
  karpenter_interruption_queue_name: ${karpenter-interruption-queue.name}
